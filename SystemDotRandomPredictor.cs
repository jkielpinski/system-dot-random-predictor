using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

public class SystemDotRandomPredictor : XoshiroImpl
{
	//Using output from Random.NextBytes()
	public static SystemDotRandomPredictor FromRandomBytes(byte[] bytes)
	{
		if (bytes.Length < sizeof(ulong)*4)
			throw new Exception($"Not enough bytes provided to determine RNG state - must be at least {sizeof(ulong)*4} bytes");

		//Grab first four ulongs
		var randomValues = new ulong[4];
		for (int i = 0; i < 4; i++)
		{
			randomValues[i] = 0;
			for (int j = 0; j < sizeof(ulong); j++)
			{
				randomValues[i] |= (ulong)bytes[i * sizeof(ulong) + j] << (j * 8);
			}
		}

		//Determine state based on ulongs
		var pred = FromRandomUInt64s(randomValues[0], randomValues[1], randomValues[2], randomValues[3]);

		//Handle the case where number of bytes generated by rng > size of 4 ulongs
		//Need to invoke the predictor to advance its state to catch up with rng state
		int extraInvocations = (int)Math.Ceiling( (double)bytes.Length / (double)sizeof(ulong) ) - 4;
		for (int i = 0; i < extraInvocations; i++)
		{
			pred.NextUInt64();
		}

		return pred;
	}

	//Using output from Random.NextInt64()
	public static SystemDotRandomPredictor FromRandomInt64s(long[] randLongs)
	{
		if (randLongs.Length < 5)
			throw new ArgumentException("Not enough random values to determine RNG state - need at least 5 longs");

		ulong[] rand = new ulong[randLongs.Length];
		for (int i = 0; i < randLongs.Length; i++) rand[i] = (ulong)randLongs[i];
		
		return FromRandomUlongsWithBitShift(rand, 1, NopLogger);
	} 

	//Using output from Random.NextDouble()
	//Note: slow (days)
	public static SystemDotRandomPredictor FromRandomDoubles(double[] rand, Logger logger = null)
	{
		if (rand.Length < 5)
			throw new ArgumentException("Not enough random values to determine RNG state - need at least 5 doubles");

		var fnInput = new ulong[rand.Length];
		for (int i = 0; i < rand.Length; i++)
		{
			fnInput[i] = (ulong)(rand[i] * (1ul << 53)) << 11;
		}

		return FromRandomUlongsWithBitShift(fnInput, 11, logger);
	}

	//Using output from Random.Next()
	//Note: extremely slow (unusable)
	public static SystemDotRandomPredictor FromRandomInts(int[] rand, Logger logger = null)
	{
		if (rand.Length < 8)
			throw new ArgumentException("Not enough random values - need at least 8 ints");

		ulong[] casted = new ulong[rand.Length];
		for (int i = 0; i < casted.Length; i++) casted[i] = (ulong)rand[i];

		return FromRandomUlongsWithBitShift(casted, 33, logger);
	}

	public delegate void Logger(string str);
	public static void StdoutLogger(string str) { Console.WriteLine(str); }
	public static void NopLogger(string str) { }

	#region Internal

	private const int Threads = 32;

	//Several of the outputs of System.Random internally take a random ulong and do bit shifts on it
	//In order to determine RNG state, we need to brute force the missing bits
	private static SystemDotRandomPredictor FromRandomUlongsWithBitShift(ulong[] rand, int bits, Logger logger = null)
	{
		if (logger == null) logger = StdoutLogger;
		ThreadPool.SetMaxThreads(Threads, Threads);

		//Discovered predictor goes here
		SystemDotRandomPredictor outPred = null;

		logger($"Brute forcing {bits*4} bits of RNG state...");
		var sw = new Stopwatch();
		sw.Start();

		var r0_base = rand[0] << bits;
		var r1_base = rand[1] << bits;
		var r2_base = rand[2] << bits;
		var r3_base = rand[3] << bits;

		var valuesToIterate = (ulong)((long)1 << bits);

		//For progress reporting
		var max = BigInteger.Pow(valuesToIterate, 4);
		var iterations = new BigInteger[Threads];
		var usedSlots = new bool[Threads];
		int threads = 0;

		//Create thread for progress reporting
		ThreadPool.QueueUserWorkItem((object? obj) => {
			do
			{
				Thread.Sleep(2000);
				if (outPred != null) break;

				BigInteger i = 0;
				foreach (var value in iterations) i += value;

				var pct = ((double)i) / ((double)max);
				var completion = (sw.ElapsedMilliseconds / pct - sw.ElapsedMilliseconds)/1000;
				var estStr = string.Format("{0:0.00}", completion);
				var pctStr = string.Format("{0:0.000}%", pct * 100);
				logger($"Threads: {ThreadPool.ThreadCount}; Possibilities tried: {i}/{max} ({pctStr}); Est time left: {FormatTime(completion)}");
			} while (ThreadPool.ThreadCount > 1 && outPred == null);
		});

		//Overall strategy is to iterate all possible permutations of the four random ulongs with mystery bits
		//The outer loop (for r0) spawns new threads for the inner loops (for r1, r2, r3)
		//for each permutation, create a SystemDotRandomPredictor and check if the randoms it produces match the input randoms
		for (ulong ii = 0; ii < valuesToIterate; ii++)
		{
			//Store in local so the inner loop lambda has the right 'i' value
			var i = ii;

			//Don't consume memory queuing up threads that won't run yet
			while (threads >= Threads) Thread.Sleep(1000);

			threads++;

			//Want to keep track of iterations for progress reporting but if every thread uses
			//the same variable it causes slowdown due to locking, so use separate slot for each thread
			int slot = 0;
			for (int s = 0; s < usedSlots.Length; s++)
			{
				if (!usedSlots[s]) {
					slot = s;
					usedSlots[s] = true;
					break;
				}
			}

			//Inner loop goes into a thread
			WaitCallback innerLoops = (object? o) =>
			{
				for (ulong j = 0; j < valuesToIterate; j++)
				{
					for (ulong k = 0; k < valuesToIterate; k++)
					{
						for (ulong l = 0; l < valuesToIterate; l++)
						{
							if (outPred != null)
							{
								threads--;
								usedSlots[slot] = false;
								return;
							}
							iterations[slot]++;

							var r0 = r0_base + i;
							var r1 = r1_base + j;
							var r2 = r2_base + k;
							var r3 = r3_base + l;

							var pred = FromRandomUInt64s(r0, r1, r2, r3, false);

							bool match = true;
							for (int m = 1; m < rand.Length; m++)
							{
								var generated = pred.NextUInt64();
								if (generated >> bits != rand[m])
								{
									match = false;
									break;
								}
							}

							if (match)
							{
								logger($"Found match: {pred}. Brute force took {sw.ElapsedMilliseconds/1000} seconds");
								outPred = pred;
								threads--;
								usedSlots[slot] = false;
								return;
							}
						}
					}
				}
				threads--;
				usedSlots[slot] = false;
			};
			if (outPred == null)
				ThreadPool.QueueUserWorkItem(innerLoops);
		}

		Thread.Sleep(1000);
		while (ThreadPool.ThreadCount > 1 && outPred == null)
		{
			Thread.Sleep(2000);
		}

		sw.Stop();
		return outPred;
	}


	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static SystemDotRandomPredictor FromRandomUInt64s(ulong rand0, ulong rand1, ulong rand2, ulong rand3, bool advance=true)
	{
		var s1_0 = CalcS1(rand0);

		var s1_1 = CalcS1(rand1);
		var s2_1 = CalcS2(s1_1, s1_0);

		var s1_2 = CalcS1(rand2);
		var s2_2 = CalcS2(s1_2, s1_1);
		var s0_1 = CalcS0(s1_1, s2_1, s1_2);

		var s1_3 = CalcS1(rand3);
		var s0_2 = CalcS0(s1_2, s2_2, s1_3);
		var s3_1 = CalcS3(s0_1, s1_1, s0_2);

		var pred = new SystemDotRandomPredictor(s0_1, s1_1, s2_1, s3_1);

		if (advance)
		{
			pred.NextUInt64();
			pred.NextUInt64();
			pred.NextUInt64();
		}

		return pred;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static ulong CalcS1(ulong randomValue) =>
		BitOperations.RotateRight(randomValue * 10248191152060862009, 7) * 14757395258967641293;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static ulong CalcS2(ulong s1_1, ulong s1_0) =>
		s1_1 ^ s1_0 ^ (s1_0 << 17);

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static ulong CalcS0(ulong s1_0, ulong s2_0, ulong s1_1) =>
		s1_1 ^ s1_0 ^ s2_0;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static ulong CalcS3(ulong s0_0, ulong s1_0, ulong s0_1) =>
		s0_0 ^ s0_1 ^ s1_0;

	public SystemDotRandomPredictor() { }

	public SystemDotRandomPredictor(ulong s0, ulong s1, ulong s2, ulong s3)
	{
		_s0 = s0;
		_s1 = s1;
		_s2 = s2;
		_s3 = s3;
	}

	public override string ToString()
	{
		return $"SystemDotRandomPredictor state: {_s0}, {_s1}, {_s2}, {_s3}";
	}

	private static string FormatTime(double seconds)
	{
		if (double.IsInfinity(seconds)) return "infinite";
		if (seconds > TimeSpan.MaxValue.TotalSeconds) return $"{(seconds/60/60/24/365)} years";

		var ts = TimeSpan.FromSeconds(seconds);
		var str = string.Empty;
		if (ts.Days > 0) str += $"{ts.Days} days, ";
		if (ts.Hours > 0) str += $"{ts.Hours} hours, ";
		if (ts.Minutes > 0) str += $"{ts.Minutes} minutes, ";
		str += $"{ts.Seconds} seconds";
		return str;
	}

	#endregion
}
