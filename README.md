# SystemDotRandomPredictor

Proof of concept for predicting the output of `System.Random` in .NET 6+ (Xoshiro256** algorithm) given previous outputs from `System.Random.NextBytes()`, `NextInt64()`, or `NextDouble()`. See my [blog post](https://jkielpinski.github.io/posts/predicting-system-dot-random/) for info about how it works.

## Usage

Create a `SystemDotRandomPredictor` in one of the following ways, depending on what `System.Random` method generated the random numbers:

|Method|Description|Est. time|
|---|---|---|
|FromRandomBytes(byte[])|From `System.Random.NextBytes()` output|instant|
|FromRandomLongs(long[])|From `System.Random.NextInt64()` output|<1sec|
|FromRandomDoubles(double[]|From `System.Random.NextDouble()` output)|2.75 days|
|FromRandomInts(int[])|From `System.Random.Next()` output|70 sextillion centuries|

You can then use the `SystemDotRandomPredictor` to predict the next values that will be produced by the `System.Random` instance.

For example, if you have the following bytes generated by `System.Random.NextBytes()`:

~~~csharp
Byte[] bytes = [ 0xFF, 0x1C, 0x75, 0x8F, 0x6C, 0x3B, 0x5E, 0x14, 0x19, 0x2C, 0x85, 0x6B, 0x2C, 0x2A, 0xA8, 0x19, 0x85, 0x36, 0x41, 0xFA, 0x5D, 0xFA, 0x0D, 0xA9, 0xF2, 0xD7, 0x4B, 0xA8, 0x79, 0x11, 0x7B, 0xD5, 0xFF, 0xE2, 0xA3, 0xDA, 0x77, 0x60, 0xE5, 0x70, 0x84, 0xBE, 0x67, 0xFE, 0x4A, 0x6A, 0x53, 0xB3 ];
~~~

Then you can create a predictor like:

~~~csharp
var predictor = SystemDotRandomPredictor.FromRandomBytes(bytes);
~~~

And use the predictor to predict the next values that will come from the RNG that generated the original bytes:

~~~csharp
predictor.Next(); // next int
predictor.NextUInt64(); // next long
predictor.NextDouble(); // next double
//... etc. All public methods from System.Random are mirrored in SystemDotRandomPredictor
~~~

The predictor matches the `System.Random` instance, so if you call `predictor.Next()` 10 times and `random.Next()` 10 times, all 10 pairs of outputs should match. Note: creating a predictor from random doubles or ints requires some brute forcing, so it takes significant time (see the blog post for explanation). It's currently impractical to brute force a `System.Random` instance based on int outputs using this code -- `FromRandomInts()` is just included for completeness.

A demo is provided in `Program.cs`. Run it with `dotnet run`. It creates some `System.Random` instances, generates random values with them, creates a `SystemDotRandomPredictor` from those random values, then verifies that the next outputs from the predictor match those from the original RNG.
